- Ideal: 
+ Dựa theo kỹ thuật chia để trị (divide and conquer). 
+ Lần lượt chia đôi mảng ban đầu thành 2 mảng con. Tiếp tục việc chia đôi mảng con như vậy cho đến khi được n mảng con (một mảng con chứa một phần tử).
+ Trộn theo thứ tự 2 mảng con được chia ra từ mảng con trước đó. Tiếp tục trộn như vậy cho đến khi nhận được một mảng có kích thước bằng với mảng ban đầu. Và mảng này cũng là mảng đã được sắp xếp theo thứ tự (tăng dần).



- Algorithm:
+ Bước 1: Cho mảng gồm n phần tử a_0, a_1, ..., a_n và l = 1, r = n.
+ Bước 2: 
    + Nếu l < r => Chuyển sang bước 3.
    + Ngược lại => Chuyển sang bước 6.
+ Bước 3: Cho mid = (l + r) / 2.
+ Bước 4: 
    + Nếu mid > 1 => Gọi 2 lần đệ quy liên tiếp nhau với mảng gồm các phần tử a_l, ..., a_mid và a_mid+1, ..., a_r.
    + Ngược lại => Chuyển sang bước 5.
+ Bước 5: Tiến hành trộn 2 mảng con bằng thuật toán trộn 2 mảng. Quay lại bước 2.
+ Bước 6: Dừng chương trình.

- Thuật toán trộn 2 mảng: a_1, a_2, ..., a_n và b_1, b_2, ..., b_m.
+ Bước 1: Khởi tạo mảng c với k = n + m phần tử và ic = ia = ib = 1.
+ Bước 2: 
    + Nếu ia <= n và ib <= m: 
	+ Nếu a_ia <= b_ib (cặp phần tử nghịch thế) => Thêm a_ia vào mảng c và tăng ia lên thêm 1.
	+ Ngược lại thêm b_ib vào mảng c và tăng ib lên thêm 1.
	+ Tăng ic lên thêm 1.
    + Ngược lại => Chuyển qua bước 3.
+ Bước 3:
    + Nếu ia <= n ===> Thêm tất cả phần tử còn lại của a vào c.
    + Ngược lại nếu ib <= m ===> Thêm tất cả phần tử còn lại của b vào c.
    + Ngược lại => Dừng chương trình.



- Time complexity: O(nlog(n)).
- Space complexity: O(n).