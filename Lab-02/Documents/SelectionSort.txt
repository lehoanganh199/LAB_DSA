- Ideal: Tìm vị trí của phần tử nhỏ nhất trong n phần tử ban đầu và đưa giá trị của phần tử đó về đầu mảng.
Tiếp tục với n - 1 phần tử còn lại. Và đến khi còn lại 1 phần tử thì phần dừng và phần tử đó chắc chắn là số lớn nhất.
=> Mảng đã được sắp xếp theo thứ tự tăng dần.

- Algorithm:
+ Bước 1: Cho mảng a[1...n] và i = 1.
+ Bước 2: 
    + Nếu i nhỏ hơn hoặc bằng n - 1 => Tiếp tục bước kế tiếp.
    + Ngược lại => Chuyển đến bước 6.
+ Bước 3: Cho pos = i và j = i + 1.
+ Bước 4: 
    + Nếu j nhỏ hơn hoặc bằng n => So sánh giá trị a[pos] và a[j].
        + Nếu a[pos] > a[j] (cặp phần tử nghịch thế) => Cập nhật lại giá trị pos bằng với j (pos = j).
        + Tăng j lên thêm 1 và quay lại bước 4.
    + Ngược lại => Chuyển sang bước 5.
+ Bước 5: 
    + Nếu i khác pos thì hoán vị hai giá trị a[i] và a[pos].
    + Tăng i lên thêm 1 và quay lại bước 2.
+ Bước 6: Dừng chương trình.


- Time complexity: O(n^2).
- Space complexity: O(1).